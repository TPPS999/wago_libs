# WagoAppControlSuite v1.0.2.0

## Overview
WAGO PLC library providing WagoAppControlSuite functionality.

**Key Features:**
- Control functions
- Professional PLC integration
- Error handling and status reporting

## Core Function Blocks

### FbTemperatureControlPWM_03
A controller with autotune functionality designed for temperature control with a digital manipulated output

**Description:**
This module represents a temperature controller with six different phases. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP5StartLevel``. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP10IdentLevel``. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``xPWM`` output is reset to zero. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typTempConfiguration.iP10StationaryEndpointControlTime`` and ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific temperature. The temperature difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the temperature difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the temperature profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typTempConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typTempConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the temperature is monitored using the ``typTempConfiguration.rP10MaxTemperatureWhileIdentification`` configuration value. When the temperature threshold is reached, the output is reset to zero and the identification process terminated. However, the process temperature can still rise further due to the properties of the controlled system. With that said, the temperature threshold should be selected as low as possible to preclude any damage due to impermissible high temperatures. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typTempConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the temperature difference between the current temperature and the new setpoint ``rSetPointValue`` it greater than ``typTempConfiguration.rMinProcessDifference`` .

### FbTemperatureControlContinous_03
A controller with autotune functionality designed for temperature control with an analog manipulated output

**Description:**
This module represents a temperature controller with six different phases. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP5StartLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP5StartLevel is used as absolute or as %-value from the setpoint. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP10IdentLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP10IdentLevel is used as absolute or as %-value from the setpoint. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``rY`` output is reset to zero by default. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typTempConfiguration.iP10StationaryEndpointControlTime`` and ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific temperature. The temperature difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the temperature difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the temperature profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typTempConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typTempConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the temperature is monitored using the ``typTempConfiguration.rP10MaxTemperatureWhileIdentification`` configuration value. When the temperature threshold is reached, the output is reset to zero and the identification process terminated. However, the process temperature can still rise further due to the properties of the controlled system. With that said, the temperature threshold should be selected as low as possible to preclude any damage due to impermissible high temperatures. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typTempConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the temperature difference between the current temperature and the new setpoint ``rSetPointValue`` it greater than ``typTempConfiguration.rMinProcessDifference`` .

### FbAutoTuneControlPWM_03
A controller with autotune functionality designed for process control with a digital manipulated output

**Description:**
This module represents a process controller with six different phases. Enabling the autotune functionality the first time is done by activating input ``xEnable`` and ``xEnableAutoTune`` at the same time. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP5StartLevel``. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP10IdentLevel``. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``xPWM`` output is reset to zero. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typConfiguration.iP10StationaryEndpointControlTime`` and ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific process value. The process difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the process difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the process profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the process value is monitored using the ``typConfiguration.rP10MaxProcessValueWhileIdentification`` configuration value. When the process value threshold is reached, the output is reset to zero and the identification process terminated. However, the process value can still rise further due to the properties of the controlled system. With that said, the process value threshold should be selected as low as possible to preclude any damage due to impermissible high process values. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the difference between the current process value and the new setpoint ``rSetPointValue`` it at least ``typConfiguration.rMinProcessDifference`` .

### FbAutoTuneControlContinous_03
A controller with autotune functionality designed for general control with an analog manipulated output

**Description:**
This module represents a process controller with six different phases. Enabling the autotune functionality the first time is done by activating input ``xEnable`` and ``xEnableAutoTune`` at the same time. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP5StartLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP5StartLevel is used as absolute or as %-value from the setpoint. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP10IdentLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP10IdentLevel is used as absolute or as %-value from the setpoint. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``rY`` output is reset to zero by default. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typConfiguration.iP10StationaryEndpointControlTime`` and ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific process value. The process difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the process difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the process profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the process value is monitored using the ``typConfiguration.rP10MaxProcessValueWhileIdentification`` configuration value. When the process value threshold is reached, the output is reset to zero and the identification process terminated. However, the process value can still rise further due to the properties of the controlled system. With that said, the process value threshold should be selected as low as possible to preclude any damage due to impermissible high process values. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the difference between the current process value and the new setpoint ``rSetPointValue`` is at least ``typConfiguration.rMinProcessDifference`` .

### Fb_PID_01
A PID controller in the additive control structure

**Description:**
This module represents a controller that allows diverse controller types, e.g., PID or PI, by selecting the ``rKp``, ``rTn`` and ``rTv`` inputs. The output value can be limited to the range from ``rOutputMin`` to ``rOutputMax``. If the controller is operated with a digital output via a PWM module, the limiting values must be set to rOutputMin

### FbAutoTuneControlPWM_02
A controller with autotune functionality designed for process control with a digital manipulated output

**Description:**
This module represents a process controller with six different phases. Enabling the autotune functionality the first time is done by activating input ``xEnable`` and ``xEnableAutoTune`` at the same time. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP5StartLevel``. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP10IdentLevel``. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``xPWM`` output is reset to zero. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typConfiguration.iP10StationaryEndpointControlTime`` and ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific process value. The process difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the process difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the process profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the process value is monitored using the ``typConfiguration.rP10MaxProcessValueWhileIdentification`` configuration value. When the process value threshold is reached, the output is reset to zero and the identification process terminated. However, the process value can still rise further due to the properties of the controlled system. With that said, the process value threshold should be selected as low as possible to preclude any damage due to impermissible high process values. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the difference between the current process value and the new setpoint ``rSetPointValue`` it at least ``typConfiguration.rMinProcessDifference`` .

### FbTemperatureControlPWM_02
A controller with autotune functionality designed for temperature control with a digital manipulated output

**Description:**
This module represents a temperature controller with six different phases. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP5StartLevel``. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP10IdentLevel``. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``xPWM`` output is reset to zero. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typTempConfiguration.iP10StationaryEndpointControlTime`` and ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific temperature. The temperature difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the temperature difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the temperature profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typTempConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typTempConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the temperature is monitored using the ``typTempConfiguration.rP10MaxTemperatureWhileIdentification`` configuration value. When the temperature threshold is reached, the output is reset to zero and the identification process terminated. However, the process temperature can still rise further due to the properties of the controlled system. With that said, the temperature threshold should be selected as low as possible to preclude any damage due to impermissible high temperatures. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typTempConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the temperature difference between the current temperature and the new setpoint ``rSetPointValue`` it greater than ``typTempConfiguration.rMinProcessDifference`` .

### FbAutoTuneControlPWM_01
A controller with autotune functionality designed for process control with a digital manipulated output

**Description:**
This module represents a process controller with six different phases. Enabling the autotune functionality the first time is done by activating input ``xEnable`` and ``xEnableAutoTune`` at the same time. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP5StartLevel``. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP10IdentLevel``. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``xPWM`` output is reset to zero. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typConfiguration.iP10StationaryEndpointControlTime`` and ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific process value. The process difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the process difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the process profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the process value is monitored using the ``typConfiguration.rP10MaxProcessValueWhileIdentification`` configuration value. When the process value threshold is reached, the output is reset to zero and the identification process terminated. However, the process value can still rise further due to the properties of the controlled system. With that said, the process value threshold should be selected as low as possible to preclude any damage due to impermissible high process values. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the difference between the current process value and the new setpoint ``rSetPointValue`` it at least ``typConfiguration.rMinProcessDifference`` .

### FbAutoTuneControlContinous_01
A controller with autotune functionality designed for general control with an analog manipulated output

**Description:**
This module represents a process controller with six different phases. Enabling the autotune functionality the first time is done by activating input ``xEnable`` and ``xEnableAutoTune`` at the same time. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP5StartLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP5StartLevel is used as absolute or as %-value from the setpoint. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typConfiguration.iP10IdentLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP10IdentLevel is used as absolute or as %-value from the setpoint. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``rY`` output is reset to zero by default. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typConfiguration.iP10StationaryEndpointControlTime`` and ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific process value. The process difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the process difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the process profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the process value is monitored using the ``typConfiguration.rP10MaxProcessValueWhileIdentification`` configuration value. When the process value threshold is reached, the output is reset to zero and the identification process terminated. However, the process value can still rise further due to the properties of the controlled system. With that said, the process value threshold should be selected as low as possible to preclude any damage due to impermissible high process values. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the difference between the current process value and the new setpoint ``rSetPointValue`` is at least ``typConfiguration.rMinProcessDifference`` .

### FbSaturation
This function block limits the input

**Description:**
The input will be limited by the values ``rOutputMax`` and ``rOutputMin``.

### FbRamp_01
Function block ensures a defined rising or falling rate of the output

**Description:**
This function block must be called in each cycle. If enabled, the output starts with the value defined by ``rRampStartValue``. Within the time period ``tRampDuration`` the signal reaches the value defined by ``rRampEndValue`` Leaving the manual mode, while xEnable is still true, will restart the signal generation, beginning with ``rRampStartValue``

### FbHysteresis_01
Hysteresis functionality

**Description:**
This Hysteresis function has two modes: #. if ``rActivate`` > ``rDeactivate`` then ``xOut`` will be TRUE when ``rIn`` > ``rActivate`` and FALSE when ``rIn`` < ``rDeactivate``. #. if ``rActivate`` < ``rDeactivate`` then ``xOut`` will be TRUE when ``rIn`` < ``rActivate`` and FALSE when ``rIn`` > ``rDeactivate``.

### FbDelay
Function block for a dead time element

**Description:**
A dead time element. An error will occure if the parameter ``MAX_DELAY`` is too small to allow for the delay defined by ``tDelay``.

### FbControlledSystemIdentification_01
This function block identifies a controlled system by evaluating the step response following the inflectional tangent method.

**Description:**
This module allows identification of a controlled system. However, a non-oscillating, non-integrating controlled system is required. The ``eControlledSystem`` input must therefore always be operated with the ``eControlledSystem.PTn`` value (additional controlled system types shall be added in the future). Identification may only be started if the system is in a steady state. Otherwise, the values are calculated incorrectly. If the module is enabled by the ``xEnable`` input, identification is started by a change at the ``rSetPoint`` input. The ``xManualOperation`` input allows to supply the controlled system manually with the value ``rSetPoint`` without the identification being carried out. This can be useful, so that identification is only executed in the vicinity of the real operating point (linearization of a nonlinear distance around the operating point). If identification is started, make sure that the ``rManipulatedValueAtStart`` input is connected correctly. If this input has an incorrect value, identification of the ``rKs`` gain factor of the controlled system is calculated incorrectly. .. Note:: The default for ``rSetPoint`` must be selected to prevent damage to the controlled system. Corresponding monitoring functions must be added to the user program. If there is no accurate knowledge of the behavior of the controlled system, start with low values for ``rSetPoint`` to get a first impression. This module maps the real controlled system behavior by PTn approximation. .. image:: ../../Images/Wendetangente_v1.PNG :align: center :alt: Wendetangente_v1 The output point for the control parameters represents the data set (rKs, rTu and rTg). The module makes the values possible for the selected ``eControllerType`` available at the ``aValues`` output. Assignment is as follows: aValues[0] ->Ziegler, extended Ziegler-Nichols method aValues[1] ->CHR_aperiodisch_dis, Chien/Hrones and Reswick, aperiodic disturbance response aValues[2] ->CHR_aperiodisch_dis, Chien/Hrones and Reswick, aperiodic response to setpoint changes aValues[3] ->CHR_20_dis, Chien/Hrones and Reswick, aperiodic disturbance response with 20 % overshoot aValues[4] ->CHR_20_dis, Chien/Hrones and Reswick, aperiodic response to setpoint changes with 20 % overshoot Only non-integrating systems are currently supported. .. image:: ../../Images/ControlledSystem_v1.PNG :align: center :alt: ControlledSystem_v1 This module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``rValue`` output is reset to zero in this case. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Evaluating both ``iStationaryEndpointControlTime`` and ``rSetPointReachedLimit`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``rSetPointReachedLimit`` percent within the specified time, it is assumed that the stationary end value has been reached.

### FbAverageMovingFilter
A average moving filter

**Description:**
The average value from ``wCount`` samples will be calculated. An error will be indicated if input ``wCount`` is greater than the parameter ``MAX_AVERAGE_MOVING_FILTER`` divided by 2.

### Fb_PWM_01
A PWM element to generate a digital signal from an analog input

**Description:**
An input signal in the range from 0% to 100%, will be transformed in a puls width signal. To increase accuracy, output values below the ``tMinimalSwitchOn`` value, will be internally stored and will be added to the next output.

### Fb_PT1
A PT1 element to design own control algorithm

**Description:**
This function block may be used as a low pass filter.

### Fb_P
A proportional element to design own control algorithm

**Description:**
A proportional element for control structures

### Fb_I
An integrator element to design own control algorithm

**Description:**
The output may be syncronized. This functionality will be perfomed with a rising edge of input ``xSyncOutput`` and will set the output to the value given by ``rManualValue``. The output will be limited by ``rOutputMax`` and ``rOutputMin``.

### Fb_D
A differentiator element to design own control algorithm

**Description:**
An ideal D-part can be archieved by setting ``rTdamping`` to zero. The output may be syncronized. This functionality will be perfomed with a rising edge of input ``xSyncOutput`` and will set the output to the value given by ``rManualValue``. The output is limited by ``rOutputMax`` and ``rOutputMin``.

### FbTemperatureControlPWM_01
A controller with autotune functionality designed for temperature control with a digital manipulated output

**Description:**
This module represents a temperature controller with six different phases. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP5StartLevel``. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP10IdentLevel``. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``xPWM`` output is reset to zero. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typTempConfiguration.iP10StationaryEndpointControlTime`` and ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific temperature. The temperature difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the temperature difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the temperature profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typTempConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typTempConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the temperature is monitored using the ``typTempConfiguration.rP10MaxTemperatureWhileIdentification`` configuration value. When the temperature threshold is reached, the output is reset to zero and the identification process terminated. However, the process temperature can still rise further due to the properties of the controlled system. With that said, the temperature threshold should be selected as low as possible to preclude any damage due to impermissible high temperatures. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typTempConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the temperature difference between the current temperature and the new setpoint ``rSetPointValue`` it greater than ``typTempConfiguration.rMinProcessDifference`` .

### FbTemperatureControlContinous_01
A controller with autotune functionality designed for temperature control with an analog manipulated output

**Description:**
This module represents a temperature controller with six different phases. Phase 1) Settling phase ->internal state 5 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP5StartLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP5StartLevel is used as absolute or as %-value from the setpoint. The system then waits until the system is in a stable state. This phase can also be used to bring the system close to the actual operating point. This is particularly important when the controlled system is non-linear, so that subsequent identification can determine the real behavior at the operating point as well as possible. Phase 2) Identification phase ->internal state 10 In this phase, the controlled system is supplied with a set value the size of ``typTempConfiguration.iP10IdentLevel``. Depending on the configuration value ``xUseLevelAsAbsoluteValue`` iP10IdentLevel is used as absolute or as %-value from the setpoint. The waveform of the controlled system response is recorded. The module returns an error if the step response cannot be recorded completely. Such is the case if the internal memory is too small. In this case, the error message is ``ArrayTooSmall``. The ``rY`` output is reset to zero by default. The problem can be resolved by increasing the ``tSampleRate`` sampling rate or increasing the ``MAX_IDENTIFICATION_ARRAY`` parameter. At the end of the identification phase, the controlled system parameters are determined using the inflectional tangent method. The output point for the control parameters represents the determined data set (``rKs``, ``rTu`` and ``rTg``). Evaluating both ``typTempConfiguration.iP10StationaryEndpointControlTime`` and ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` inputs determines when the stationary end value is reached during the identification phase. If the process value does not change more than the ``typTempConfiguration.rP10StationaryEndpointPercentReferenceValue`` percent within the specified time, it is assumed that the stationary end value has been reached. This module also allows you to interrupt identification early or to start calculating the controller parameters immediately. This can be useful if the stationary end value is reached very slowly. In this case, the operator can estimate the end value from the ``rStationaryEndvalue`` input directly and trigger calculation by the ``xReleasedByOperator`` input. Phase 3) Controlling the intermediate setpoint ->internal state 20 Following the identification phase, the system reaches a specific temperature. The temperature difference from the setpoint actually specified is determined. In this phase, the control parameters are set to an intermediate setpoint that is 50 % of the temperature difference. Therefore, you have the option of roughly estimating the quality of the control parameters. Phase 4) Controlling the setpoint ->internal state 30 In this phase, the specified setpoint is controlled with the calculated control parameters. The quality of the control must be assessed by the operator and improved by manual optimization, if necessary. It is recommended to use the trace functionality to get a visual impression of the temperature profile. The system switches to phase 5 once the setpoint is reached. Phase 5) Maintain setpoint (regulating disturbance variables) ->internal state 40 The controller operates with the controller set determined by the ``typTempConfiguration.eP40ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_dis``. If a new setpoint is identified, the system switches to phase 6. Phase 6) Regulating the setpoint step change ->internal state 50 The controller operates with the controller set determined by the ``typTempConfiguration.eP50ControlMethode`` configuration value. The default value is ``CHR_aperiodisch_set``. Once the new setpoint is reached with the corresponding accuracy, the system switches to phase 5. .. note:: Since the controlled system gain is unknown during initial identification, the temperature is monitored using the ``typTempConfiguration.rP10MaxTemperatureWhileIdentification`` configuration value. When the temperature threshold is reached, the output is reset to zero and the identification process terminated. However, the process temperature can still rise further due to the properties of the controlled system. With that said, the temperature threshold should be selected as low as possible to preclude any damage due to impermissible high temperatures. If an error interrupts identification, the function block must be disabled once. You can then restart with a reduced value for ``typTempConfiguration.iP10IdentLevel``. This module can also be used as a traditional PID controller if the ``xUseExternalControlParameter`` is set to TRUE. In this case, the controller operates with the ``rKp``, ``rTn`` and ``rTv`` input values. .. note:: A second identification phase is only performed if the temperature difference between the current temperature and the new setpoint ``rSetPointValue`` it greater than ``typTempConfiguration.rMinProcessDifference`` .

### Fb_PID
A PID controller in the additive control structure

**Description:**
This module represents a controller that allows diverse controller types, e.g., PID or PI, by selecting the ``rKp``, ``rTn`` and ``rTv`` inputs. The output value can be limited to the range from ``rOutputMin`` to ``rOutputMax``. If the controller is operated with a digital output via a PWM module, the limiting values must be set to rOutputMin

## Usage Examples

### Basic Usage
```iec
VAR
    fbFbTemperatureControlPWM_03: FbTemperatureControlPWM_03;
END_VAR

// Basic function block usage
fbFbTemperatureControlPWM_03(
    // Configure inputs as needed
);

// Check status
IF fbFbTemperatureControlPWM_03.xValid THEN
    // Operation successful
END_IF

IF fbFbTemperatureControlPWM_03.xError THEN
    // Handle error
END_IF
```

## Best Practices

### Error Handling
```iec
IF fbInstance.xError THEN
    CASE fbInstance.eStatus OF
        // Handle specific error codes
    END_CASE
END_IF
```

### Performance Considerations
- Use appropriate polling intervals
- Handle communication errors gracefully
- Consider device response times
- Test thoroughly in target environment

## Important Notes

- This documentation was automatically generated from XML specification
- Always refer to official WAGO documentation for complete details
- Test thoroughly in your specific application environment
- Check library compatibility with your PLC hardware

